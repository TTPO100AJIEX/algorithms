<html>
    <head>
        <script src="https://www.gstatic.com/charts/loader.js"></script>
        <style>
            * { line-height: 1.5; margin: 0; padding: 0; }
            [hidden] { display: none !important; content-visibility: hidden !important; }
            
            body > label { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); font-size: 1.5rem; font-weight: bold; text-align: center; overflow: auto; }
            ::file-selector-button { font-size: 1.25rem; padding: 0.25rem; }

            main { width: max-content; display: grid; grid-template-columns: repeat(6, 1fr); gap: 1rem; }
            p { padding: 0 1rem; overflow: auto; max-width: 900px; max-height: 150px; }
        </style>
        <script type="module">
            if (!("google" in window)) alert("Google charts failed to load! Please check your internet connection!");
            google.charts.load('current', { 'packages': ['corechart'] });
            
            document.getElementById("file_input").addEventListener("change", ev =>
            {
                let reader = new FileReader();
                reader.addEventListener("load", ev => drawCharts(JSON.parse(ev.currentTarget.result)));
                reader.readAsText(ev.target.files[0], "utf-8");
            });


            function algorithmToString(algorithm)
            {
                switch(algorithm)
                {
                    case "naive": return "Наивный";
                    case "naive-no-break": return "Наивный полный";
                    case "kmp": return "КМП";
                    case "kmp-optimized": return "Уточ. КМП";
                    case "aho-corasick": return "Ахо-Корасик";
                }
            }
            function substitutionsToString(substitutions)
            {
                switch (substitutions)
                {
                    case 0: return "0 символов подстановки";
                    case 1: return "1 символ подстановки";
                    default: return `${substitutions} символа подстановки`;
                }
            }
            function textToSizeString(textId)
            {
                return `${textId.split('-')[0]} символов`;
            }
            function textToAlphabetString(textId)
            {
                return `алфавит ${textId.split('-')[1]}`;
            }
            function textToString(textId)
            {
                return textToSizeString(textId) + ", " + textToAlphabetString(textId);
            }

            
            const descriptions = {
                "10000-01":
                {
                    "0":    `1. Как показывают линии тренда и их коэффициенты детерминации (близкие к единице), время выполнения всех рассматриваемых алгоритмов ` + 
                                `действительно линейно зависит от длины шаблона при отсутствии символов подстановки.\n` +
                            `2. Тем не менее алгоритм Ахо-Корасик работает значительно дольше остальных. Но это ожидаемо: алгоритм Ахо-Корасик предназначен для ` + 
                                `поиска вхождений нескольких подстрок в текст одновременно, из-за чего имеет большую "константу" - при работе алгоритм производит ` +
                                `большое количество "сложных" операций, таких как выделение памяти, а также осуществляет многократный проход по искомому шаблону\n` + 
                            `3. Интересно, что наивный алгоритм при большой длине шаблона показывает себя лучше остальных. Более того, график времени выполнения ` +
                                `наивного алгоритма убывает с увеличением длины шалона. Это объясняется тем, что наивный алгоритм ` +
                                `- наиболее простой из рассматриваемых, а случайность данных позволяет ему не проверять шаблон до конца каждый раз и производить значительно ` +
                                `меньше операций, чем ожидается в худшем случае. И это подтверждается тем, что при минимальной длине шаблона наивный алгоритм не оказывается лучшим\n` +
                            `4. Использование уточнённых граней в алгоритме Кнута-Морриса-Пратта действительно позволяет улучшить время работы и делает его более "стабильным" ` +
                                `- отклонения от линии тренда оказываются заметно меньше\n` +
                            `5. Линия тренда для времени выполнения алгоритма Ахо-Корасик имеет коэффициент детерминации 0.999, что, с учетом низкой зависимости реализации от входных ` + 
                                `данных, подтверждает, что влияние внешних факторов на результаты измерений незначительно, а отклонения от линии тренда действительно вызваны лишь ` +
                                `случайностью входных данных, а не окружением, в котором программа запускалась`,
                    "1":    `По сравнению с результатом, полученным для этого же текста при отсутствии символов подстановки, можно отметить следующее:\n` + 
                            `1. Обе версии алгоритма КМП показали заметно более плохой результат, что ожидаемо: для добаления "поддержки" символов подстановки в алгоритм КМП необходимо ` +
                                `внести значительные изменения, усложняющие алгоритм. В анализируемой реализации происходит деление шаблона на части по символу подстановки, поиск отдельных частей ` + 
                                `в тексте и подбор подходящих индексов путём проверки того, что необходимые части действительно расположены в тексте подряд.\n` + 
                            `2. Интересно, что кривая зависимости времени выполнения от длины шаблона убывает для алгоритма КМП, но возврастает для алгоритма КМП с использованием уточнённых граней. ` + 
                                `Скорее всего, это также связано с описанными ранее особенностями генерации данных и реализации алгоритмов.\n` +
                            `3. Наивный алгоритм уверенно оказывается наиболее эффективным из-за лёгкости реализации "поддержки" символов подстановки: описанная ранее для алгоритма КМП идея не требуется ` +
                                `для наивного алгоритма. Более того, время выполнения наивного алгоритма практически не изменилось из-за добавления символа подстановки.\n` + 
                            `4. Добавление символа подстановки не оказало значительного влияния и на Алгоритм Ахо-Корасик. Несмотря на то, что для добавления "поддержки" символов подстановки необходимо ` +
                                `"следовать" той же идее, что и для алгоритма КМП, алгоритм Ахо-Корасик позволяет производить поиск частей шаблона одновременно, что "компенсирует" затраты на отбор индексов.`,
                    "2":    `1. Вновь можно отметить, что добавление символа подстановки не повлияло на время выполнения наивного алгоритма и алгоритма Ахо-Корасик, но эффективность обеих версий алгоритма КМП ` +
                                `значительно снизилась. На шаблонах минимальной длины алгоритм Ахо-Корасик показывает себя даже лучше, чем КМП. Причины этого аналогичны описанным ранее.\n` + 
                            `2. Интересно, что при добавлении второго символа подстановки график времени выполнения для алгоритма КМП с уточнёнными гранями сменил свою монотонность на убывание. ` + 
                                `Скорее всего, это связано с возрастанием расходов на отбор индексов: для коротких шаблонов после разбиения по символам подстановки получаются маленькие части, которые ` + 
                                `входят в текст большое количество раз, что вызывает дополнительные операции выделения памяти и сравнения индексов`,
                    "3":    `1. Закономерность сохраняется: с добавлением символов подстановки эффективность алгоритма КМП снижается. При трёх символах подстановки КМП оказывается менее эффективным, ` +
                                `чем алгоритм Ахо-Корасик, уже при шаблонах длины не только 100 и 200, но и 300 и 400\n` +
                            `2. Убывание кривой для алгоритма КМП с уточнёнными гранями оказывается ещё более явным. Причины этому аналогичны описанным ранее.`,
                    "4":    `1. Алгоритм Кнута-Морриса-Пратта теряет эффективность ещё больше: для четырёх символов подстановки алгоритм Ахо-Корасик оказывается эффективнее КМП и при шаблоне длины 500.\n` +
                            `2. Вновь, кривые для версий алгоритма КМП начинают убывать ещё сильнее.`,
                    "30":   `1. При 30 символах подстановки алгоритм КМП ухудшается настолько, что Ахо-Корасик оказывается эффективнее практически на всех шаблонах.\n` +
                            `2. Наивный алгоритм всё равно оказывается самым эффективным из-за высокой случайности входных данных\n` + 
                            `3. При шаблонах маленькой длины алгоритм Ахо-Корасик оказывается крайне неэффективным. Скорее всего, это связано с большими накладными расходами на отбор индексов после поиска ` +
                                `(аналогично описанному ранее для алгоритма КМП с уточнёнными гранями). Если в шаблоне маленькой длины (100) большое количество символов подстановки (30), то части шаблона после ` +
                                `разбиения оказываются короткими и входят в текст большое количество раз, что вызывает большое количество дополнительных операций, в том числе "дорогих" (выделений памяти), при отборе индексов`
                },
                "10000-abcd":
                {
                    "0":    `График выглядит аналогично полученному для текста длины 10000 над алфавитом 01 без символов подстановки. Интересно отметить лишь следующее:\n` +
                            `1. Эффективность наивного алгоритма оказывается немного хуже: при длине шаблона 100 линия практически пересекает график времени работы алгоритма ` +
                                `Кнута-Морриса-Пратта, а пересечение с графиком времени работы алгоритма КМП с уточнёнными гранями происходит лишь при длине шаблона 1000 (вместо 700)\n` +
                            `2. Абсолютная величина времени работы алгортима Ахо-Корасик увеличилась, что ожидаемо: алгоритм зависит от размера алфавита. Но время работы остальных ` +
                                `алгоритмов уменьшилось, что также ожидаемо: чем больше длина алфавита, тем меньше вероятность, что первое "несовпадение" с шаблоном произойдёт близко ` +
                                `к концу шаблона, а значит алгоритм быстрее "отвергнет" возможный ответ, что улучшает время работы`,
                    "1":    `В результатах прослеживаются те же закономерности, что и при изменений алфавита без символа подстановки и при добавлении символа подстановки в текст над бинарным алфавитом:\n` + 
                            `1. Из-за изменения алфавита время работы всех алгоритмов, кроме Ахо-Корасик, уменьшилось.\n` + 
                            `2. Из-за добавления символа подстановки время работы обеих версий алгоритма КМП увеличилось, а наивный алгоритм оказался явным лидером.`,
                    "2":    `Прослеживаются аналогичные закономерности:\n` + 
                            `1. Из-за добавления символа подстановки обе версии алгоритма КМП стали менее эффективными, а соответствующие им кривые стали убывать сильнее.\n` + 
                            `2. Из-за изменения алфавита время работы алгоритма Ахо-Корасик увеличилось, а остальных алгоритмов - уменьшилось.\n` + 
                            `3. Интересно, что коэффициент детерминации линии тренда алгоритма КМП с уточнёнными гранями маленький на этом наборе тестов, хотя для обычного алгорита КМП близок к единице. ` + 
                                `Скорее всего, это также связано с генерацией тестовых данных, так как от расположения символов подстановки могут сильно зависеть расходы на отбор индексов.`,
                    "3":    `Общие тренды всё те же:\n` + 
                            `1. Из-за добавления символа подстановки обе версии алгоритма КМП теряют эффективность, а соответствующие им кривые убывают сильнее.\n` + 
                            `2. Из-за изменения алфавита время работы алгоритма Ахо-Корасик увеличилось, а остальных алгоритмов - уменьшилось.\n` +
                            `3. В совокупности явно выделяется одно значительное изменение: для шаблона длины 100 алгоритм Ахо-Корасик становится эффективнее КМП`,
                    "4":    `Добавление символа подстановки приводит к тому, что алгоритм КМП продолжает ухудшаться, из-за чего Ахо-Корасик оказывается эффективнее уже на первых трёх шаблонах`,
                    "30":   `Аналогично описанному ранее, прослеживается резкое ухудшение эффективности алгоритма Ахо-Корасик на шаблоне длины 100, но на шаблонах длины от 200 до 2000 он ` +
                            `обходит алгоритм КМП, а при длине до 1700 и алгоритм КМП с уточнёнными гранями`
                },
                "100000-01":
                {
                    "0":    `График выглядит аналогично полученному для текста длины 10000. Отмечу лишь следующие отличия:\n` +
                            `1. Абсолютные величины заметно увеличились. Значит, время выполнения анализируемых алгоритмов зависит не только от размера шаблона, но и от размера текста.\n` +
                            `2. Разница во времени выполнения между алгоритмом Ахо-Корасик и остальными алгоритмами сократилась: на больших шаблонах алгоритм Ахо-Корасик лишь в два раза хуже остальных ` +
                                `по абсолютной величине времени выполнения (вместо почти восьми для текста длины 10000). Таким образом, размер текста влияет на время выполнения анализируемых алгоритмов ` +
                                `не одинаково. Действительно, время выполнения наивного алгоритма и версий алгоритма КМП возросло прмерно в 9 раз, в то время как время работы алгоритма Ахо-Корасик - лишь в 2.5 раза\n` + 
                            `3. Использование уточнённых граней значительно улучшает алгоритм КМП. Более того, алгоритм КМП с использованием уточнённых граней оказывается наиболее эффективным, превосходя по ` +
                                `эффективности наивный алгоритм\n` + 
                            `4. Линии тренда для обоих вариантов алгоритма КМП имеют маленький коэффициент детерминации. Действительно, хотя общий вид кривых и указывает на линейную зависимость времени выполнения ` +
                                `алгоритмов от длины шаблона, линии сильно изломаны, что понижает "качество" линии тренда. Скорее всего, это объясняется случайностью данных: "если повезёт", алгоритм пропустит большую ` +
                                `часть операций`,
                    "1":    `Вновь прослеживаются известные закономерности:\n` + 
                            `1. Из-за добавления символа подстановки время работы обеих версий алгоритма КМП увеличилось. Более того, алгоритм Ахо-Корасик оказывается лишь незначительно хуже ` + 
                                `алгоритма КМП с уточнёнными гранями и даже превосходит по эффективности обычную версию алгоритма КМП при шаблонах длины меньше 1700\n` +
                            `2. Из-за увеличения длины текста абсолютные величины времени также увеличились.\n` + 
                            `3. Также интересно заметить, что увеличение длины текста повлияло на алгоритм КМП значительно сильнее, чем на Ахо-Корасик: если для текста длины 10000 Ахо-Корасик был эффективнее КМП лишь ` +
                                `на самом коротком шаблоне, то для текста длины 100000 Ахо-Корасик становится хуже КМП лишь при длине шаблона 1700\n` +
                            `4. Также интересно, что коэффициент детерминации линии тренда для наивного алгоритма достаточно мал, что, скорее всего, связано с высокой случайностью входных данных и большой длиной текста, ` +
                                `что позволило проявиться всем деталям выполнения алгоритма и вызвало заметные отклонения от линии тренда.`,
                    "2":    `Добавление второго символа подстановки привело к ухудшению эффективности вариантов алгоритма КМП настолько, что Ахо-Корасик оказывается медленнее ` + 
                                `алгоритма КМП с уточнёнными гранями лишь при длине шаблона свыше 2300 (вновь заметим, что это число гораздо больше, чем для текста длины 10000) и эффективнее ` +
                                `обычного КМП на всех рассматриваемых шаблонах`,
                    "3":    `Добавление третьего символа подстановки ещё сильнее ухудшает вариации алгоритма КМП, и Ахо-Корасик на рассматриваемых шаблонах становится "уверенно" эффективнее обеих версий`,
                    "4":    `Разница между алгоритмами КМП и Ахо-Корасик с добавлением четвёртого символа подстановки становится ещё более явной. Тем не менее наивный алгоритм всё равно наиболее эффективен.`,
                    "30":   `Аналогично текстам длины 10000, наблюдается значительное ухудшение эффективности алгоритма Ахо-Корасик на первых нескольких шаблонах, но на шаблонах большой длины алгоритм Ахо-Корасик по ` +
                            `эффективности оказывается в 7-8 раз лучше версий алгоритма КМП и лишь в два раза хуже наивного алгоритма`
                },
                "100000-abcd":
                {
                    "0":    `1. Интересно, что время выполнения всех алгоритмов уменьшилось по сравнению с текстом длины 100000 над алфавитом 01.\n` +
                            `2. Наивный алгоритм теряет свою эффективность. Несмотря на то, что при большой длине шаблона время выполнения наивного алгоритма практически совпадает со временем работы алгоритма КМП, ` +
                                `на маленьких шаблонах КМП заметно превосходит наивный алгоритм по эффективности\n` +
                            `3. Коэффициент детерминации для обеих версий алгоритма КМП достаточно мал, что вновь говорит о высоком влиянии способа генерации данных на результаты измерений.`,
                    "1":    `1. Из-за добавления символа подстановки время работы алгоритма КМП, как было неоднократно отмечено ранее, увеличилось, из-за чего наивный алгоритм вновь оказался наиболее эффективным.\n` + 
                            `2. Алгоритм Ахо-Корасик показал достаточно странные результаты: для некоторых шаблонов время работы оказывается сильно меньше ожидаемого. Скорее всего, это связано с особенностями генерации входных данных.\n` +
                            `3. Интересно, что коэффициент детерминации для наивного алгоритма оказался достаточно маленьким. Это лишь подтверждает, что большой разброс результатов действительно вызван не очень "хорошими" входными данными.`,
                    "2":    `Как и для остальных текстов, с увеличением количества символов подстановки в шаблоне наблюдается значительное ухудшение эффективности версий алгоритма КМП`,
                    "3":    `Вновь наблюдается ухудшение эффективности версий алгоритма КМП, а Ахо-Корасик оказывается эффективнее алгоритма КМП с использованием обычных граней на маленьких шаблонах. ` + 
                            `Интересно, что добавление очереденого символа подстановки при поиске в тексте над алфавитом abcd влияет на эффективность алгоритма меньше, чем при анализе текста над бинарным алфавитом, ` +
                            `из-за чего алгоритм Ахо-Корасик не кажется столь эффективным на этом тексте`,
                    "4":    `На большинстве шаблонов Ахо-Корасик оказывается лучше КМП с обычными гранями, а на некоторых превосходит и КМП с уточнёнными гранями.`,
                    "30":   `Вновь проявляется крайняя неэффективность алгоритма Ахо-Корасик на маленьком шаблоне, но на шаблонах длины больше 200 он оказывается значительно эффективнее КМП как с обычными, так и с уточнёнными гранями`
                }
            };


            let algorithms = [ ], texts = [ ], substitutions = [ ], patterns = [ ];
            function drawCharts(data)
            {
                texts = Object.keys(data).sort();
                substitutions = Object.keys(data[texts[0]]).map(e => Number(e)).sort((a, b) => a - b);
                patterns = Object.keys(data[texts[0]][substitutions[0]]).map(e => Number(e)).sort((a, b) => a - b);
                algorithms = Object.keys(data[texts[0]][substitutions[0]][patterns[0]]).sort();

                document.getElementsByTagName("label").item(0).hidden = true;
                document.getElementsByTagName("main").item(0).hidden = false;

                for (const textId of texts)
                {
                    for (const substitutionSymbols of substitutions)
                    {
                        const chartData = [
                            [ "Pattern size", ...algorithms.map(algorithmToString) ],
                            ...patterns.map(patternSize => [ patternSize, ...algorithms.map(algorithm => average(data[textId][substitutionSymbols][patternSize][algorithm])) ] )
                        ];
                        drawChart(chartData, `${textToString(textId)}, ${substitutionsToString(substitutionSymbols)}`);
                    }
                    for (const substitutionSymbols of substitutions)
                    {
                        const p = document.createElement("p"); p.innerText = descriptions[textId][substitutionSymbols];
                        document.getElementsByTagName("main").item(0).appendChild(p);
                    }
                }
            }
            

            function average(arr)
            {
                const removeItems = Math.floor(arr.length / 10); // Remove 10% worst and 10% best
                if (removeItems != 0) arr = arr.sort().slice(removeItems, -removeItems);
                return arr.reduce((acc, cur) => acc + cur, 0) / arr.length;
            }
            function drawChart(chartData, title)
            {
                const div = document.createElement("div");
                document.getElementsByTagName("main").item(0).appendChild(div);
                const chart = new google.visualization.LineChart(div);

                let trendlines = [ ];
                for (let i = 1; i < chartData[0].length; i++)
                {
                    trendlines[i - 1] = { type: 'linear', showR2: true, visibleInLegend: true, labelInLegend: `${chartData[0][i]} (тренд)`, lineWidth: 1, pointSize: 2 };
                }

                chart.draw(google.visualization.arrayToDataTable(chartData),
                {
                    width: 900, height: 450, chartArea: { width: 600 },
                    fontSize: 12, focusTarget: "category", pointSize: 4, lineWidth: 3,
                    title: title, titleTextStyle: { fontSize: 16 },
                    explorer: { maxZoomIn: 0.01, maxZoomOut: 1.25, zoomDelta: 1.1, axis: 'vertical' },
                    hAxis: { title: 'Длина шаблона', titleTextStyle: { fontSize: 14, bold: true } },
                    vAxis: { title: 'Время выполнения (ns)', titleTextStyle: { fontSize: 14, bold: true } },
                    trendlines: trendlines
                });
            }
        </script>
    </head>
    <body>
        <label>
            Пожалуйста, загрузите data.json эксперимента<br>
            <input type="file" accept=".json" id="file_input">
        </label>
        <main hidden>
        </main>
    </body>
</html>