<html>
    <head>
        <script src="https://www.gstatic.com/charts/loader.js"></script>
        <style>
            * { line-height: 1.5; margin: 0; padding: 0; }
            body { display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: repeat(5, min-content) 1fr; column-gap: 2rem; row-gap: 0.25rem; align-items: flex-start; }

            body > label { grid-column: 1 / -1; grid-row: 1 / -1; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); font-size: 1.5rem; font-weight: bold; text-align: center; }
            ::file-selector-button { font-size: 1.25rem; padding: 0.25rem; }

            body > h2 { grid-column: 1 / -1; text-align: center; }
            body > h3 { text-align: center; }

            body > .group { display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; gap: 0.5rem; height: min-content; }
            body > .group .chosen { background: blue; color: white; }
            body > .group > h3 { grid-column: span 2; text-align: center; padding: 0.25rem; }

            body > hr { grid-column: 1 / -1; }
        </style>
        <script>
            google.charts.load('current', {'packages': ['corechart'] });

            function algorithmToString(algorithm)
            {
                switch (algorithm)
                {
                    case "BINARY_INSERTION": { return "Бинарными вставками"; }
                    case "BUBBLE_1": { return "Пузырьком с условием Айверсона 1"; }
                    case "BUBBLE_2": { return "Пузырьком с условием Айверсона 1+2"; }
                    case "BUBBLE": { return "Пузырьком"; }
                    case "COUNTING": { return "Подсчетом (устойчивая)"; }
                    case "HEAP": { return "Пирамидальная"; }
                    case "INSERTION": { return "Простыми вставками"; }
                    case "MERGE": { return "Слиянием"; }
                    case "QUICK": { return "Быстрая (первый опорный)"; }
                    case "RADIX": { return "Цифровой"; }
                    case "SELECTION": { return "Выбором"; }
                    case "SHELL_CIUR": { return "Шелла (последовательность Циура)"; }
                    case "SHELL": { return "Шелла (последовательность Шелла)"; }
                }
            }
            function typeToString(type)
            {
                switch (type)
                {
                    case "RANDOM_SMALL": { return "Случайные 0-5"; }
                    case "RANDOM_BIG": { return "Случайные 0-4000"; }
                    case "ALMOST_SORTED": { return "Почти отсортированный"; }
                    case "BACKWARDS_SORTED": { return "Обратно отсортированный"; }
                }
            }
            function drawTypeToString(key)
            {
                switch (key)
                {
                    case "time": return "Время работы (ns)";
                    case "operations": return "Количество операций";
                }
            }

            var groups = { }, template = [ [ 'Array length' ] ];
            window.addEventListener("load", () =>
            {
                document.getElementById("input_file").addEventListener("change", ev =>
                {
                    let reader = new FileReader();
                    reader.addEventListener("load", e =>
                    {
                        const results = JSON.parse(e.currentTarget.result);
                        function parseResults(key)
                        {
                            groups[key] ??= [ ];
                            for (let groupIndex = 0; groupIndex < results[key][Object.keys(results[key])[0]].length; groupIndex++)
                            {
                                const groupExample = results[key][Object.keys(results[key])[0]][groupIndex];
                                groups[key].push({
                                    types: Object.keys(groupExample),
                                    algorithms: Object.keys(results.time),
                                    data: { },
                                    template: [ [ 'Array length' ], ...Object.keys(groupExample[Object.keys(groupExample)[0]]).map(e => [ Number(e)] ) ]
                                });
                                const storage = groups[key].at(-1);
                                for (const type of storage.types)
                                {
                                    storage.data[type] = { };
                                    for (const algorithm of storage.algorithms) storage.data[type][algorithm] = Object.values(results[key][algorithm][groupIndex][type]);
                                }
                            }
                        }
                        parseResults("time");
                        parseResults("operations");
                        setupCharts();
                    });
                    reader.readAsText(ev.target.files[0]);
                });
            });

            function setupCharts()
            {
                Array.from(document.body.children).forEach(e => e.remove());
                { let h2 = document.createElement("h2"); h2.innerText = "Выбор отображаемых графиков"; document.body.appendChild(h2); }
                for (let groupIndex = 0; groupIndex < groups[Object.keys(groups)[0]].length; groupIndex++)
                {
                    let group = document.createElement("div"); group.className = "group";
                    let h3 = document.createElement("h3"); h3.innerText = `Group ${groupIndex + 1}`; group.appendChild(h3);
                    let typesButton = document.createElement("button"); typesButton.innerText = "По видам"; group.appendChild(typesButton); typesButton.addEventListener("click", () => drawCharts(groupIndex, "types")); typesButton.id = `${groupIndex}_types`;
                    let algorithmsButton = document.createElement("button"); algorithmsButton.innerText = "По алгоритмам"; group.appendChild(algorithmsButton); algorithmsButton.addEventListener("click", () => drawCharts(groupIndex, "algorithms")); algorithmsButton.id = `${groupIndex}_algorithms`;
                    document.body.appendChild(group);
                }
                { document.body.appendChild(document.createElement("hr")); }
                { let h2 = document.createElement("h2"); h2.innerText = "Графики"; document.body.appendChild(h2); }
                { let h3 = document.createElement("h3"); h3.innerText = "По времени"; document.body.appendChild(h3); }
                { let h3 = document.createElement("h3"); h3.innerText = "По количеству элементарных операций"; document.body.appendChild(h3); }
                { let div = document.createElement("div"); div.id = "time"; document.body.appendChild(div); }
                { let div = document.createElement("div"); div.id = "operations"; document.body.appendChild(div); }
            }
            

            function draw(groupIndex, grouping, drawType)
            {
                const holder = document.getElementById(drawType), group = groups[drawType][groupIndex]; Array.from(holder.children).forEach(e => e.remove());
                switch(grouping)
                {
                    case "types":
                    {
                        for (const type of group.types)
                        {
                            let chartData = JSON.parse(JSON.stringify(group.template));
                            for (const algorithm of group.algorithms)
                            {
                                chartData[0].push(algorithmToString(algorithm));
                                for (let i = 0; i < group.data[type][algorithm].length; i++) chartData[i + 1].push(group.data[type][algorithm][i]);
                            }
                            chartData = google.visualization.arrayToDataTable(chartData);
                            let div = document.createElement("div"); holder.appendChild(div);
                            let chart = new google.visualization.LineChart(div);
                            chart.draw(chartData, { width: holder.getBoundingClientRect().width, height: Math.max(holder.getBoundingClientRect().width * 2/3, 400), title: `${drawTypeToString(drawType)} на массивах типа "${typeToString(type)}"`, titleTextStyle: { fontSize: 18 }, explorer: { maxZoomIn: 0.01, maxZoomOut: 1.25, zoomDelta: 1.1 } });
                        }
                        break;
                    }
                    case "algorithms":
                    {
                        for (const algorithm of group.algorithms)
                        {
                            let chartData = JSON.parse(JSON.stringify(group.template));
                            for (const type of group.types)
                            {
                                chartData[0].push(typeToString(type));
                                for (let i = 0; i < group.data[type][algorithm].length; i++) chartData[i + 1].push(group.data[type][algorithm][i]);
                            }
                            chartData = google.visualization.arrayToDataTable(chartData);
                            let div = document.createElement("div"); holder.appendChild(div);
                            let chart = new google.visualization.LineChart(div);
                            chart.draw(chartData, { width: holder.getBoundingClientRect().width, height: Math.max(holder.getBoundingClientRect().width * 2/3, 400), title: `${drawTypeToString(drawType)} для сортировки ${algorithmToString(algorithm)}`, titleTextStyle: { fontSize: 18 }, explorer: { maxZoomIn: 0.01, maxZoomOut: 1.25, zoomDelta: 1.1 } });
                        }
                        break;
                    }
                }
            }
            function drawCharts(groupIndex, grouping)
            {
                Array.from(document.querySelectorAll(".group > button")).forEach(e => e.classList.remove("chosen"));
                document.getElementById(`${groupIndex}_${grouping}`).classList.add("chosen");
                draw(groupIndex, grouping, "time");
                draw(groupIndex, grouping, "operations");
            }
        </script>
    </head>
    <body>
        <label>
            Upload data.json<br>
            <input type="file" accept=".json" id="input_file">
        </label>
    </body>
</html>