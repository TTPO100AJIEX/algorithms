<!--
1) АиСД-2, 2023, задание 5
2) Абрамов Александр Сергеевич БПИ213
3) Visual Studio Code
4) Реализованы 13 алгоритмов сортировки массива, программы генерации тестовых данных и проведения тестирования,
    а также измерения времени выполнения и количества произведённых элементарных операций.
    Реализованы программы обработки полученных данных: формирования корректных xlsx-файлов и построения графиков.
5) Если я правильно понял задание, то все сделано)
-->
<html>
    <head>
        <script src="https://www.gstatic.com/charts/loader.js"></script>
        <style>
            * { line-height: 1.5; margin: 0; padding: 0; }
            body { display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: repeat(5, min-content) 1fr; column-gap: 2rem; row-gap: 0.25rem; align-items: flex-start; }

            body > label { grid-column: 1 / -1; grid-row: 1 / -1; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); font-size: 1.5rem; font-weight: bold; text-align: center; }
            ::file-selector-button { font-size: 1.25rem; padding: 0.25rem; }

            body > h2 { grid-column: 1 / -1; text-align: center; }
            body > h3 { text-align: center; }

            body > .group { display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; gap: 0.5rem; height: min-content; }
            body > .group .chosen { background: blue; color: white; }
            body > .group > h3 { grid-column: span 2; text-align: center; padding: 0.25rem; }
            
            body > hr { grid-column: 1 / -1; }
            
            #time, #operations { display: grid; grid-auto-rows: 65vh 15vh; }
            p { padding: 0 1rem; overflow: auto; }
        </style>
        <script>
            google.charts.load('current', {'packages': ['corechart'] });

            function algorithmToString(algorithm)
            {
                switch (algorithm)
                {
                    case "BINARY_INSERTION": { return "Бинарными вставками"; }
                    case "BUBBLE_1": { return "Пузырьком с условием Айверсона 1"; }
                    case "BUBBLE_2": { return "Пузырьком с условием Айверсона 1+2"; }
                    case "BUBBLE": { return "Пузырьком"; }
                    case "COUNTING": { return "Подсчетом (устойчивая)"; }
                    case "HEAP": { return "Пирамидальная сортировка"; }
                    case "INSERTION": { return "Простыми вставками"; }
                    case "MERGE": { return "Слиянием"; }
                    case "QUICK": { return "Быстрая сортировка с первым опорным"; }
                    case "RADIX": { return "Цифровой"; }
                    case "SELECTION": { return "Выбором"; }
                    case "SHELL_CIUR": { return "Шелла (последовательность Циура)"; }
                    case "SHELL": { return "Шелла (последовательность Шелла)"; }
                }
            }
            function typeToString(type)
            {
                switch (type)
                {
                    case "RANDOM_SMALL": { return "Случайные 0-5"; }
                    case "RANDOM_BIG": { return "Случайные 0-4000"; }
                    case "ALMOST_SORTED": { return "Почти отсортированный"; }
                    case "BACKWARDS_SORTED": { return "Обратно отсортированный"; }
                }
            }
            function drawTypeToString(key)
            {
                switch (key)
                {
                    case "time": return "Время выполнения (ns)";
                    case "operations": return "Количество элементарных операций";
                }
            }

            var groups = { }, template = [ [ 'Array length' ] ], descriptions = {
                "time":
                [
                    {
                        "types":
                        {
                            "RANDOM_SMALL": `1. Можно заметить, что сортировка слиянием является довольно неэффективным алгоритмом, оказываясь лучше лишь сортировки пузырьком и сортировки выбором при размере массива более 200.<br>
                                            2. Линейные сортировки, ожидаемо, довольно плохи при маленьких данных, но обходят остальные алгоритмы на массивах с 200 и более элементами.<br>
                                            3. Сортировка вставками оказывается достаточно эффективным алгоритмом на этих данных, несмотря на свою квадратичную теоретическую сложность.`,
                            "RANDOM_BIG": `1. Сортировка подсчётом кажется довольно неэффективным алгоритмом, обходя большинство 'конкурентов' лишь в конце графика.<br>
                                            2. Цифровая сортировка оказывается наиболее эффективным алгоритмом при длине массива свыше 150.<br>
                                            3. Сортировка слиянием также кажется довольно плохим алгоритмом, оказываясь хуже всех на очень маленьких данных и обходя только вариации сортировки пузырьком и сортировку выбором в конце графика.<br>
                                            4. Сортировка простыми вставками, несмотря на квадратичную сложность, оказывается довольно производительной.`,
                            "ALMOST_SORTED": `1. Базовая вариация сортировки пузырьком "отделилась" от своих версий с условием Айверсона, которые стали значительно эффективнее.<br>
                                            2. Сортировка слиянием неэффективна и для этого типа массивов.<br>
                                            3. Сортировка вставками оказывается самым эффективным алгоритмом, превосходя даже линейные сортировки.`,
                            "BACKWARDS_SORTED": `1. Оба условия Айверсона лишь ухудшают производительность сортировки пузырьком, а условие Айвесрона 1+2 оказывается крайне неэффективной попыткой оптимизации.<br>
                                                2. Быстрая сортировка стала одним из худших алгоритмов наравне с сортировкой пузырьком.<br>
                                                3. Сортировка слиянием, удивительно, показывает хороший результат.<br>
                                                4. Сортировка Шелла оказывается лидером, обходя даже линейные алгоритмы сортировки.`
                        },
                        "algorithms":
                        {
                            "BINARY_INSERTION": `Ожидаемо, "худший случай" сортировки - обратно отсортированный массив, а "лучший случай" - почти отсортированный.`,
                            "BUBBLE_1": `Ожидаемо, "лучший случай" - почти отсортированный массив, но интересно, что теоретический "худший случай" - обратно отсортированный массив - не являеся худшим на практике.`,
                            "BUBBLE_2": `Ожидаемо, "лучший случай" - почти отсортированный массив, а "худший случай" - обратно отсортированный массив, хотя отставание и невелико.`,
                            "BUBBLE": `Интересно, что при вводе особых массивов - обратно отсортированного и почти отсортированного - сортировка работает эффективнее. Скорее всего, это вызвано архитектурными особенностями системы.`,
                            "COUNTING": `Ожидаемо, что сортировка работает наиболее быстро на почти отсортированном массиве и случайном массиве с маленькими элементами, так как время работы сортировки подсчётом зависит от диапазона значений элементов массива.`,
                            "HEAP": `Сложность пирамидальной сортировки не зависит от типа массива.`,
                            "INSERTION": `Ожидаемо, "лучший случай" - почти отсортированный массив, "худший случай" - обратно отсортированный массив.`,
                            "MERGE": `Интересно, что сортировка слиянием работает наиболее эффективно на обратно отсортированном массиве, что объясняется архитектурными особенностями системы - загрузкой элементов массива в кэш процессора до того, как они непосредственно необходимы.`,
                            "QUICK": `Ожидаемо, "худший случай" - обратно отсортированный массив, так как при таких входных данных быстрая сортировка с первым опорным имеет квадратичную сложность.<br>
                                        Тем не менее стоило бы ожидать, что на почти отсортированном массиве сортировка тажке будет неэффективна, так как на каждом шаге не удаётся делить массив приблизительно пополам, но эта гипотеза не подтверждается экспериментально.`,
                            "RADIX": `С некоторой точностью получен ожидаемый результат - одинаковая эффективность алгоритма на любых данных, но из-за особенностей системы сортировка работает немного более эффективно на случайном массиве больших данных.`,
                            "SELECTION": `Можно считать, что время работы сортировки выбором мало зависит от типа массива. Тем не менее явно выделяется график времени выполнения программы при сортировке случайного массива больших данных. Скорее всего, это также вызвано архитектурными особенностями системы.`,
                            "SHELL_CIUR": `Интересно, что "худший случай" - случайный массив с большими числами, а "лучший случай" - обратно отсортированный массив, несмотря на то, что "под капотом" сортировки Шелла лежит несколько сортировок вставками. Получается, что их комбинация действительно позволила значительно улучшить алгоритм.`,
                            "SHELL": `Результаты приблизительно совпадают с полученными для сортировки Шелла с последовательностью Циура, лишь абсолютные значения времени немного больше.`
                        }
                    },
                    {
                        "types":
                        {
                            "RANDOM_SMALL": `1. Сортировка пузырьком - наименее эффективный алгоритм, даже с применением условий Айверсона.<br>
                                            2. Быстрая сортировка оказывается не самым эффективным алгоритмом из-за большого количества повторяющихся значений.<br>
                                            3. График времени выполнения сортировки Шелла с последовательностью Шелла не ровный, а возврастает скачками - в тот момент, когда для сортировки массива требуется дополнительная итерация внешнего цикла.<br>
                                            4. Линейные сортировки, ожидаемо, значительно превосходят остальные алгоритмы при большой длине массива.`,
                            "RANDOM_BIG": `Результат эксперимента похож на полученный ранее для случайного массива с маленькими числами за исключением нескольких моментов:<br>
                                            1. Быстрая сортировка становится значительно эффективнее, так как при генерации случайного массива с большими числами повторений значений гораздо меньше.<br>
                                            2. Сортировка Шелла теряет свою эффективность и по производительности приблизительно совпадает с пирамидальной сортировкой и сортировкой слиянием.`,
                            "ALMOST_SORTED": `График похож на результат аналогичного эксперимента для первой группы тестов:<br>
                                            1. Базовая вариация сортировки пузырьком "отделилась" от своих версий с условием Айверсона, которые стали значительно эффективнее.<br>
                                            2. Быстрая сортировка оказывается очень неэффективной по понятным причинам: если массив почти отсортирован, то большинство делений массива происходят не пополам, из-за чего сложность алгоритма "деградирует" до квадратичной.<br>
                                            3. Условия Айверсона позволяют повысить эффективность сортировки пузырьком на столько, что алгоритм обходит пирамидальную сортировку.<br>
                                            4. Сортировка вставками оказывается самым эффективным нелинейным алгоритмом, практически обходя линейные сортировки.`,
                            "BACKWARDS_SORTED": `Результат вновь похож на полученный для массивов маленького размера: <br>
                                                1. Сортировка пузырьком с условием Айверсона 1+2 работает значительно медленнее всех остальных алгоритмов.<br>
                                                2. Ожидаемо, быстрая сортировка показывает плохие результаты ("худший случай").`
                        },
                        "algorithms":
                        {
                            "BINARY_INSERTION": `Ожидаемо, "худший случай" сортировки - обратно отсортированный массив, а "лучший случай" - почти отсортированный.`,
                            "BUBBLE_1": `Ожидаемо, "лучший случай" - почти отсортированный массив, но интересно, что теоретический "худший случай" - обратно отсортированный массив - не являеся явно худшим на практике.`,
                            "BUBBLE_2": `Ожидаемо, "лучший случай" - почти отсортированный массив, а "худший случай" - обратно отсортированный массив.`,
                            "BUBBLE": `Интересно, что при вводе особых массивов - обратно отсортированного и почти отсортированного - сортировка работает эффективнее. Скорее всего, это вызвано архитектурными особенностями системы.`,
                            "COUNTING": `Ожидаемо, сортировка работает наиболее быстро случайном массиве с маленькими элементами, так как время работы сортировки подсчётом зависит от диапазона значений элементов массива. Также отметим, что время работы сортировки на почти отсортированных данных постепенно возврастает, что вызвано увеличением значений элементов массива с ростом его длины по построению тестовых данных.`,
                            "HEAP": `Сложность пирамидальной сортировки не зависит от типа массива, хотя интересно, что эффективность работы на случайном массиве с большими значениями ниже, чем на массивах других типов, что вызвано особенностями архитектуры системы.`,
                            "INSERTION": `Ожидаемо, "лучший случай" - почти отсортированный массив, "худший случай" - обратно отсортированный массив.`,
                            "MERGE": `Сортировка слиянием работает наиболее эффективно на обратно отсортированном массиве, а наиболее медленно - на случайном массиве с большими значениями, что объясняется только архитектурными особенностями системы и устройством кэша процессора.`,
                            "QUICK": `Ожидаемо, "худший случай" - обратно отсортированный массив, так как при таких входных данных быстрая сортировка с первым опорным имеет квадратичную сложность.<br>
                                        Тем не менее стоило бы ожидать, что на почти отсортированном массиве сортировка тажке будет неэффективна, так как на каждом шаге не удаётся делить массив приблизительно пополам, но эта гипотеза не подтверждается экспериментально.<br>
                                        Также хочется отметить, что время работы алгоритма на случайном массиве с большими значениями заметно ниже, чем на массивах остальных типов, что обусловлено маленьким количеством повторений значений в массиве и, следовательно, возможностью делить массив приблизительно пополам при выборе первого элемента как опорного.`,
                            "RADIX": `С некоторой точностью получен ожидаемый результат - одинаковая эффективность алгоритма на любых данных, но из-за особенностей системы сортировка работает немного менее эффективно на случайном массиве маленьких данных из-за необходимости выполнения большого количество операций "вхолостую".`,
                            "SELECTION": `Можно считать, что время работы сортировки выбором мало зависит от типа массива. Тем не менее явно выделяется график времени выполнения программы при сортировке случайного массива больших данных. Скорее всего, это также вызвано архитектурными особенностями системы.`,
                            "SHELL_CIUR": `Интересно, что "худший случай" - случайный массив с большими числами, а "лучший случай" - обратно отсортированный массив, несмотря на то, что "под капотом" сортировки Шелла лежит несколько сортировок вставками. Получается, что их комбинация действительно заметно повлияла на алгоритм.`,
                            "SHELL": `Результаты приблизительно совпадают с полученными для сортировки Шелла с последовательностью Циура, лишь абсолютные значения времени немного больше.`
                        }
                    }
                ],
                "operations":
                [
                    {
                        "types":
                        {
                            "RANDOM_SMALL": `Результат заметно отличается от графика времени выполнения: <br>
                                            1. В теории (без учёта затрат на системные вызовы выделения памяти, которые необходимы сортировке слиянием) этот алгоритм показывает себя вполне неплохо.
                                            2. Аналогично, сортировка подсчётом в теории кажется значительно эффективнее, чем не практике.<br>
                                            3. Но сортировка вставками напротив на практике оказывается значительно эффективнее теоретической оценки.`,
                            "RANDOM_BIG": `Аналогично предыдущему измерению можно отметить, что график измерения количества элементарных операций не совсем отражает график времени выполнения из-за того,
                                            что при подсчёте элементарных операций не учитывались в том числе затраты на вызовы ОС.`,
                            "ALMOST_SORTED": `1. Снова теоретические оценки эффективности сортировок слиянием и подсчётом слишком оптимистичны.<br>
                                            2. Не учитывая слишком хорошую оценку для линейных сортировок, вычисление количества элементарных операция подтверждает, что сортировка простыми вставками наиболее эффективна на этих данных.<br>
                                            3. Условия Айверсона действительно позволяют значительно улучшить эффективность сортировки пузырьком.`,
                            "BACKWARDS_SORTED": `1. Линии явно разделились на несколько групп: сортировки пузырьком, сортировки вставками, быстрая сортировка и сортировка выбором, остальные сортировки.<br>
                                                2. Для цифровой сортировки теоретическая оценка очень оптимистична, а для сортировки Шелла наоборот завышена.<br>
                                                3. Пирамидальная сортировка по количеству элементарных операций достаточно эффективна, что не совсем подтверждается практическим результатом.`
                        },
                        "algorithms":
                        {
                            "BINARY_INSERTION": `Замер количества элементарных операций подтверждает полученные эксперементально значения.`,
                            "BUBBLE_1": `"Лучший случай", полученный экспериментально, подтверждается, а обратно отсортированный массив, в отличие от результата измерения времени, действительно является "худшим случаем".`,
                            "BUBBLE_2": `Измеренное количество элементарных операций подтверждает результат, полученный экспериментально. Сортировка пузырьком с условием Айверсона 1+2 работает наиболее эффективно на почти отсортированном массиве и плохо при вводе обратно отсортированного массива.`,
                            "BUBBLE": `Ожидаемо, сложность сортировки пузырьком не зависит от типа массива.`,
                            "COUNTING": `Результат подтверждает полученные экспериментально данные - чем меньше элементы массива, тем эффективнее работает сортировка.`,
                            "HEAP": `Сложность пирамидальной сортировки не зависит от типа массива.`,
                            "INSERTION": `Теоретическая оценка подтверждает результат эксперимента.`,
                            "MERGE": `Результат ожидаем, хотя и не совпадает с полученным экспериментально, - сложность сортировки слиянием не зависит от типа массива.`,
                            "QUICK": `"Худший случай" подтверждается - обратно отсортированный массив. Почти отсортированный массив хотя и не является "худшим случаем", но близок к нему, так как большая часть делений массива происходит не пополам.`,
                            "RADIX": `Ожидаемо, сложность цифровой сортировки не зависит от устройства входного массива.`,
                            "SELECTION": `Ожидаемо, сложность сортировки выбором не сильно зависит от типа массива.`,
                            "SHELL_CIUR": `Полученный "худший случай" совпадает с экспериментальным, но интересно, что теоретически сортировка Шелла обрабатывает обратно отсортированный массив не так эффективно, как было получено в результате эксперимента.`,
                            "SHELL": `Ожидаемо, вид графика похож на полученный для сортировки Шелла с последовательностью Циура.`
                        }
                    },
                    {
                        "types":
                        {
                            "RANDOM_SMALL": `Теоретическая оценка подтверждает результаты эксперимента: сортировка пузырькой действительно является наименее эффективной, а линейные сортировки - наиболее, в то время как график сортировки Шелла с последовательностью Шелла действительно возрастает скачкообразно не только на практике.`,
                            "RANDOM_BIG": `Оценка количества элементарных операций подтверждает экспериментальные результаты: действительно, быстрая сортировка на этом типе массива значительно эффективнее, а сортировка Шелла потеряла преимущество.`,
                            "ALMOST_SORTED": `Результат в целом подтверждает данные, полученные экспериментально за исключением нескольких моментов:<br>
                                            1. С точки зрения количества элементарных операций ожидается, что пирамидальная сортировка обходит сортировку пузырьком с условиями Айверсена, что не подтверждается экспериментально.<br>
                                            2. Сортировки слиянием и бинарными вставками в теории показывают себя гораздо лучше, чем на практике, приближаясь по времени выполнения к сортировке Шелла, что не наблюдается в графике времени выполнения.<br>`,
                            "BACKWARDS_SORTED": `Можно заметить, что алгоритмы можно явно разделить на три группы:<br>
                                                1. Сортировки пузырьком. Отметим, что с точки зрения количества элементарных операций условие Айверсона 1+2 не ухудшает эффективность алгоритма, что произошло на практике.<br>
                                                2. Сортировки вставками, сортировка выбором и быстрая сортировка, для каждой из которых обратно отсортированный массив - "худший случай".<br>
                                                3. Остальные сортировки, распределившиеся в ожидаемом порядке: пирамидальная сортировка, сортировка Шелла, сортировка слиянием, линейные сортировки.
                            `
                        },
                        "algorithms":
                        {
                            "BINARY_INSERTION": `Замер количества элементарных операций подтверждает полученные эксперементально значения.`,
                            "BUBBLE_1": `"Лучший случай", полученный экспериментально, подтверждается, а обратно отсортированный массив, в отличие от результата измерения времени, действительно является "худшим случаем".`,
                            "BUBBLE_2": `Измеренное количество элементарных операций подтверждает результат, полученный экспериментально. Сортировка пузырьком с условием Айверсона 1+2 работает наиболее эффективно на почти отсортированном массиве и плохо при вводе обратно отсортированного массива.`,
                            "BUBBLE": `Ожидаемо, сложность сортировки пузырьком не сильно зависит от типа массива.`,
                            "COUNTING": `Результат подтверждает полученные экспериментально данные - чем меньше элементы массива, тем эффективнее работает сортировка, а сильное возрастание времени работы алгоритма с увеличением длины вводимого почти отсортированного массива объясняется устройством тестовых данных.`,
                            "HEAP": `Сложность пирамидальной сортировки не зависит от типа массива.`,
                            "INSERTION": `Теоретическая оценка подтверждает результат эксперимента.`,
                            "MERGE": `Результат ожидаем, хотя и не совпадает с полученным экспериментально, - сложность сортировки слиянием не зависит от типа массива.`,
                            "QUICK": `"Худший случай" подтверждается - обратно отсортированный массив. Почти отсортированный массив хотя и не является "худшим случаем", но близок к нему, так как большая часть делений массива происходит не пополам.`,
                            "RADIX": `Ожидаемо, сложность цифровой сортировки не зависит от устройства входного массива.`,
                            "SELECTION": `Ожидаемо, сложность сортировки выбором не сильно зависит от типа массива.`,
                            "SHELL_CIUR": `Полученный "худший случай" совпадает с экспериментальным, но интересно, что теоретически сортировка Шелла обрабатывает обратно отсортированный массив не так эффективно, как было получено в результате эксперимента.`,
                            "SHELL": `Ожидаемо, вид графика похож на полученный для сортировки Шелла с последовательностью Циура.`
                        }
                    }
                ]
            };
            window.addEventListener("load", () =>
            {
                document.getElementById("input_file").addEventListener("change", ev =>
                {
                    let reader = new FileReader();
                    reader.addEventListener("load", e =>
                    {
                        const results = JSON.parse(e.currentTarget.result);
                        if (!results.is_wsl) descriptions = { };
                        function parseResults(key)
                        {
                            groups[key] ??= [ ];
                            for (let groupIndex = 0; groupIndex < results[key][Object.keys(results[key])[0]].length; groupIndex++)
                            {
                                const groupExample = results[key][Object.keys(results[key])[0]][groupIndex];
                                groups[key].push({
                                    types: Object.keys(groupExample),
                                    algorithms: Object.keys(results.time),
                                    data: { },
                                    template: [ [ 'Array length' ], ...Object.keys(groupExample[Object.keys(groupExample)[0]]).map(e => [ Number(e)] ) ],
                                    minTest: Math.min(...Object.keys(groupExample[Object.keys(groupExample)[0]]).map(e => [ Number(e)] )) - 50,
                                    maxTest: Math.max(...Object.keys(groupExample[Object.keys(groupExample)[0]]).map(e => [ Number(e)] )) + 50
                                });
                                const storage = groups[key].at(-1);
                                for (const type of storage.types)
                                {
                                    storage.data[type] = { };
                                    for (const algorithm of storage.algorithms) storage.data[type][algorithm] = Object.values(results[key][algorithm][groupIndex][type]);
                                }
                            }
                        }
                        parseResults("time");
                        parseResults("operations");
                        setupCharts();
                    });
                    reader.readAsText(ev.target.files[0]);
                });
            });

            function setupCharts()
            {
                Array.from(document.body.children).forEach(e => e.remove());
                { let h2 = document.createElement("h2"); h2.innerText = "Выбор отображаемых графиков"; document.body.appendChild(h2); }
                for (let groupIndex = 0; groupIndex < groups[Object.keys(groups)[0]].length; groupIndex++)
                {
                    let group = document.createElement("div"); group.className = "group";
                    let h3 = document.createElement("h3"); h3.innerText = `Group ${groupIndex + 1}`; group.appendChild(h3);
                    let typesButton = document.createElement("button"); typesButton.innerText = "По видам"; group.appendChild(typesButton); typesButton.addEventListener("click", () => drawCharts(groupIndex, "types")); typesButton.id = `${groupIndex}_types`;
                    let algorithmsButton = document.createElement("button"); algorithmsButton.innerText = "По алгоритмам"; group.appendChild(algorithmsButton); algorithmsButton.addEventListener("click", () => drawCharts(groupIndex, "algorithms")); algorithmsButton.id = `${groupIndex}_algorithms`;
                    document.body.appendChild(group);
                }
                { document.body.appendChild(document.createElement("hr")); }
                { let h2 = document.createElement("h2"); h2.innerText = "Графики"; document.body.appendChild(h2); }
                { let h3 = document.createElement("h3"); h3.innerText = "Времени"; document.body.appendChild(h3); }
                { let h3 = document.createElement("h3"); h3.innerText = "Количества элементарных операций"; document.body.appendChild(h3); }
                { let div = document.createElement("div"); div.id = "time"; document.body.appendChild(div); }
                { let div = document.createElement("div"); div.id = "operations"; document.body.appendChild(div); }
            }
            

            function draw(groupIndex, grouping, drawType)
            {
                const holder = document.getElementById(drawType), group = groups[drawType][groupIndex]; Array.from(holder.children).forEach(e => e.remove());
                switch(grouping)
                {
                    case "types":
                    {
                        for (const type of group.types)
                        {
                            let chartData = JSON.parse(JSON.stringify(group.template));
                            for (const algorithm of group.algorithms)
                            {
                                chartData[0].push(algorithmToString(algorithm));
                                for (let i = 0; i < group.data[type][algorithm].length; i++) chartData[i + 1].push(group.data[type][algorithm][i]);
                            }
                            chartData = google.visualization.arrayToDataTable(chartData);
                            let div = document.createElement("div"); holder.appendChild(div);
                            let chart = new google.visualization.LineChart(div);
                            chart.draw(chartData, {
                                title: `${drawTypeToString(drawType)} на массивах типа "${typeToString(type)}"`,
                                titleTextStyle: { fontSize: 18 },
                                explorer: { maxZoomIn: 0.01, maxZoomOut: 1.25, zoomDelta: 1.1, axis: 'vertical' },
                                hAxis: { title: 'Размер массива', titleTextStyle: { fontSize: 16, bold: true }, minValue: group.minTest, maxValue: group.maxTest },
                                vAxis: { title: drawType == 'time' ? 'Время выполнения (ns)' : 'Количество элементарных операций', titleTextStyle: { fontSize: 16, bold: true }, logScale: true }
                            });

                            let p = document.createElement("p"); holder.appendChild(p);
                            p.innerHTML = descriptions[drawType]?.[groupIndex]?.types?.[type] ?? ``;
                        }
                        break;
                    }
                    case "algorithms":
                    {
                        for (const algorithm of group.algorithms)
                        {
                            let chartData = JSON.parse(JSON.stringify(group.template));
                            for (const type of group.types)
                            {
                                chartData[0].push(typeToString(type));
                                for (let i = 0; i < group.data[type][algorithm].length; i++) chartData[i + 1].push(group.data[type][algorithm][i]);
                            }
                            chartData = google.visualization.arrayToDataTable(chartData);
                            let div = document.createElement("div"); holder.appendChild(div);
                            let chart = new google.visualization.LineChart(div);
                            chart.draw(chartData, {
                                title: `${drawTypeToString(drawType)} для сортировки ${algorithmToString(algorithm)}`,
                                titleTextStyle: { fontSize: 18 },
                                explorer: { maxZoomIn: 0.01, maxZoomOut: 1.25, zoomDelta: 1.1, axis: 'vertical' },
                                hAxis: { title: 'Размер массива', titleTextStyle: { fontSize: 16, bold: true }, minValue: group.minTest, maxValue: group.maxTest },
                                vAxis: { title: drawType == 'time' ? 'Время выполнения (ns)' : 'Количество элементарных операций', titleTextStyle: { fontSize: 16, bold: true }, logScale: true }
                            });

                            let p = document.createElement("p"); holder.appendChild(p);
                            p.innerHTML = descriptions[drawType]?.[groupIndex]?.algorithms?.[algorithm] ?? ``;
                        }
                        break;
                    }
                }
            }
            function drawCharts(groupIndex, grouping)
            {
                Array.from(document.querySelectorAll(".group > button")).forEach(e => e.classList.remove("chosen"));
                document.getElementById(`${groupIndex}_${grouping}`).classList.add("chosen");
                draw(groupIndex, grouping, "time");
                draw(groupIndex, grouping, "operations");
            }
        </script>
    </head>
    <body>
        <label>
            Upload data.json<br>
            <input type="file" accept=".json" id="input_file">
        </label>
    </body>
</html>